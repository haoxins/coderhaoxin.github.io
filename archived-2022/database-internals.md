---
title: 数据库系统内幕
description: 少焉, 月出于东山之上, 徘徊于斗牛之间. 白露横江, 水光接天.
date: 2022-03-11
---

* [数据库系统内幕](https://book.douban.com/subject/35078474/)
  - 作为**微信读书**付费会员, 为微信读书的`时效性`提升点赞

---

## 存储引擎简介

* **空间局部性**原则是**局部性原则**之一. 该原则指出,
  如果访问一处存储, 则其附近的其他存储区域也会在不久的将来被访问.

* 认为`行存储`和`列存储`之间的区别仅在于数据的存储方式有所不同, 这是不充分的.
  选择数据布局只是列式存储所针对的一系列可能的优化的步骤之一.
  - 在一次读取中, 从同一列中读取多个值可以显著提高缓存利用率和计算效率.
    在现代 `CPU` 上, 向量化指令可以使单条 `CPU` 指令一次处理多个数据点.
  - 另外, 将具有相同数据类型的值存储在一起可以提高压缩率.
    我们可以根据不同的数据类型使用不同的压缩算法,
    并为每种情况选择最有效的压缩方法.

* 面向列的数据库不应与宽列式存储 (如 `BigTable` 或 `HBase`) 相混淆.
  在这些数据库中, 数据表示为多维映射, 列被分组为列族 (通常存储相同类型的数据),
  并且在每个列族中, 数据被逐行存储.
  - 此布局最适合存储由一个键或一组键来检索的数据.

* 索引文件的大小通常比数据文件小. 文件被划分成页 (`page`),
  每个页通常具有单个或多个磁盘块的大小.
  - 页可以被组织成记录的序列或分槽页 (`slotted page`) .
* 新增记录 (插入) 和对现有记录的更新使用`键/值`对来表示.
  大多数现代存储系统不显式地删除页上的数据.
* 相反, 它们使用删除标记 (`deletion marker`, 也称为墓碑 (`tombstone`)),
  其中包含此删除动作的元数据, 如键和时间戳. 在垃圾收集过程中,
  这些被更新或被删除标记遮盖 (`shadowed`) 过的记录所占用的空间会被数据库回收.
  该过程会读取页, 然后将活动 (即未被遮盖) 的记录写入新位置, 并丢弃被遮盖的记录.

* 主 (数据) 文件上的索引称为主索引. 但是, 在大多数情况下,
  我们还可以假设主索引是在主键或作为主键的一组键之上构建的.
  所有其他索引都称为二级索引 (`secondary index`).
* 二级索引可以直接指向数据记录, 也可以简单地存储它的主键.
  指向数据记录的指针可以保存堆文件或索引组织表中的偏移量.

* 如果数据记录的顺序遵循搜索键顺序, 则这种索引称为聚簇索引
  (`clustered/clustering index`).
  聚簇索引中的数据记录通常与索引存储于同一文件,
  有时也存放在单独的聚簇文件中, 而这些文件均保留了键的顺序.
* 如果数据存储在单独的文件中, 且其顺序不遵循键顺序,
  则索引称为非聚簇索引 (`nonclustered/unclustered index`) .

* 索引组织表以索引的顺序保存数据, 因此按定义一定是聚簇的.
  主索引通常是聚簇的, 而根据定义, 二级索引一定不是聚簇的,
  因为它们是用于加速主键以外的键的访问的.
  - 聚簇索引既可以是索引组织的,
    也可以具有单独的索引和数据文件.

* 如果工作负载主要由读操作组成, 那么更新几个索引可能没有什么问题,
  但是对于具有多个索引, 以写为主的工作负载, 这种方法便不能很好地工作了.
* 为了减少指针更新的成本, 一些数据库的具体实现是使用主键进行间接操作,
  而不是直接使用数据偏移量.

* 通常, `LSM`树和`B`树之间的区别便是数据是不可变的还是原地更新的,
  但是也存在受`B`树启发但不可变的数据结构.

## B树基础知识

* 在深入研究`B`树之前, 让我们先讨论一下为什么应该考虑替代传统搜索树
  (例如, 二分搜索树, `2-3`树和`AVL`树).

* 一棵**二分搜索树**中只能有一个根节点.
* 每个节点将搜索空间分为左子树和右子树:
  - 一个节点的键大于其左子树中存储的任何键,
  - 且小于其右子树中存储的任何键.
* 插入操作并不会遵循任何特定模式, 元素插入可能导致树不平衡的情况
  (即它的一个分支比另一个分支长). 最差的情况得到一棵病态树, 更像一个链表,
  此时我们得到的不是期望的对数时间复杂度, 而是线性时间复杂度.

* 平衡树指的是高度为
  $$ \log_2 N $$
  的树 (其中 `N` 是树中数据项的总数),
  并且两个子树之间的高度差不大于 `1`.

* 树的平衡是通过以最小化树高并将每一边的节点数
  保持在界限内的方式重新组织节点来完成的.
* 保持树的平衡的方法之一是在添加或删除节点后执行旋转:
  如果插入操作使分支不平衡 (分支中的两个连续节点只有一个子节点),
  则可以围绕中间节点旋转树.

* 由于扇出较低 (扇出是指每个节点允许拥有的最大子节点数),
  我们必须相当频繁地执行平衡操作, 重新定位节点并更新指针.
  维护成本的增加使得二分搜索树作为存储在磁盘上的数据结构变得不切实际.

* 适合磁盘实现的树必须具有以下属性:
  - 高扇出, 以改善邻近键的数据局部性.
  - 低高度, 以减少遍历期间的寻道次数.

* 典型的 `SSD` 由记忆单元构成, 这些单元连接成串
  (每个串通常为 `32` 到 `64` 个单元),
  串被组合成阵列, 阵列被组合成页, 页被组合成块.
* 可写 (可编程) 或可读的最小单元是页. 但是, 我们只能对空的记忆单元进行更改
  (即, 对写入之前已擦除的单元进行更改).
* 最小的擦除实体不是页, 而是保存多个页的块, 这就是为什么它通常被称为擦除块.
  空块中的页必须按顺序写入.
* 每当我们从块设备读取单个字时, 包含它的整个块将会被读取.
  这是我们不能忽视的一个限制, 在处理基于磁盘存储的数据结构时应该始终考虑到这一点.

* 每当我们从块设备读取单个字时, 包含它的整个块将会被读取.
  这是我们不能忽视的一个限制,
  在处理基于磁盘存储的数据结构时应该始终考虑到这一点.

---

* `B`树是有序的: `B`树节点内的键按顺序存储. 因此,
  我们可以使用像二分搜索这样的算法来定位搜索到的键.
  这也意味着`B`树中的查找具有对数复杂度.
* 使用`B`树, 我们可以有效地执行单点查询和范围查询.
  在大多数查询语言中, 我们通过谓词相等 `(=)`
  表示单点查询来定位单个项, 而通过谓词比较
  `(<, >, ≤ 和 ≥)`
  表示范围查询来按顺序查询多个数据项.

* `B`树由多个节点组成. 每个节点最多可容纳`N`个键和`N+1`个指向子节点的指针.
  这些节点在逻辑上分为三类.
  - **根节点**: 根节点没有父节点, 是树的顶端.
  - **叶节点**: 叶节点是没有子节点的底层节点.
  - **内部节点**: 连接根节点和叶节点的其他节点,
    `B`树通常包含多层的内部节点.

* 由于`B`树是一种页组织技术 (即用于组织和导航固定大小的页的技术),
  所以节点和页这两个术语在描述中可相互替换.
* 节点容量与其实际持有的键的个数之间的关系称为占用率.
* `B`树的特征在于其扇出 (fanout):
  存储在每个节点中的键的个数. 为保持树的平衡需要做出一些结构上的更改,
  而更高的扇出则有助于均摊这些更改的所带来的开销.
* 同时, 通过在单个块或多个连续块中存储指向子节点的键和指针,
  可以减少寻道的次数.

* `B`树允许在根节点, 内部节点和叶节点当中的任意层上储存值.
  而`B+`树则仅在叶节点中存储值, 其内部节点仅存储分隔键,
  用于指引搜索算法去找到叶节点上的关联值.

* `B+`树广为人知, 因此我们像其他文献中一样称之为`B`树.

* 存储在`B`树节点中的键称为索引条目 (`index entry`),
  分隔键 (`separator key`) 或分隔符单元格 (`divider cell`).
* 它将树分割成子树 (也称为分支或子范围), 其持有包含对应键的范围.
  键存储时已经排好序, 以便使用二分搜索.
* 查找算法通过定位一个键并跟随相应的指针从较高的层次移动到较低的层次来找到一个子树.

* 使`B`树与众不同的是, 它不是自上而下构建的 (像二分搜索树那样),
  而是采用相反的构建方式 -- 自下而上. 随着叶节点数量的增加,
  内部节点的数量和树的高度也将增加.
* 由于`B`树在节点内部为将来的插入和更新保留了额外的空间,
  所以树的存储占用率可以低至`50%`, 但通常这个数值要高得多.
  较高的占用率不会对`B`树的性能产生负面影响.

* 更准确地说, 如果以下条件成立, 则需要分裂节点:
  - 对于叶节点: 如果节点最多可以容纳 `N` 个键值对,
    且再插入一个键值对将使其超过其最大容量 `N`.
  - 对于非叶节点: 如果节点最多可以容纳 `N+1` 个指针,
    且再插入一个指针将使其超过其最大容量 `N+1`.
* 分裂是通过分配新节点, 将一半元素从原分裂节点传输给它
  并添加它的第一个键和指向父节点的指针来完成的.
  - 在这种情况下, 我们说这个键被提升 (promote) 了.
    执行分裂处的数组下标称为分裂点 (也称为中点).
  - 分裂点之后的所有元素 (在非叶节点分裂的情况下, 包括分裂点)
    都被传输到新创建的兄弟节点, 其余元素保留在分裂节点中.
  - 如果父节点已满, 即没有容纳被提升的键和指向新创建节点的指针的空间时,
    也必须分裂父节点. 此操作可能会一直递归传播到根节点.

* 分裂完成后有两个节点, 我们必须选择正确的节点才能完成插入.
  为此, 我们可以使用分隔键不变量. 如果插入的键小于要提升的键,
  则最后插入到原分裂节点. 否则, 我们将要插入的键放入新创建的节点.
* 总之, 节点分裂分为四个步骤:
  1. 分配一个新节点.
  2. 将一半元素从分裂节点复制到新节点.
  3. 将新元素放入相应节点.
  4. 在分裂节点的父节点处, 添加一个分隔键和指向新节点的指针.

* 更准确地说, 如果满足以下条件, 则合并两个节点:
  - 对于叶节点: 如果一个节点可以容纳最多 `N` 个键值对,
    并且两个相邻节点中的键值对的数目加起来小于或等于 `N`.
  - 对于非叶节点: 如果一个节点可以容纳最多 `N+1` 个指针,
    并且两个相邻节点中指针的数量加起来小于或等于 `N+1`.

* 总之, 假设元素已经被删除, 节点合并分为三步:
  1. 从右节点复制所有元素到左节点.
  2. 从父节点删除右节点指针 (如果是非叶子节点合并, 则将此指针进行降级).
  3. 删除右节点.
* 为了减少分裂和合并的次数, `B` 树经常采用的技术之一是再平衡.

## 文件格式

* 磁盘数据结构中指针管理的语义与内存中的有所不同,
  你可以将磁盘上的`B`树看作一种页管理机制:
  - 算法需要组合页并在页中移动.
  - 需要计算页和指向它们的指针并将它们放置在相应的位置.

* 大多数的数值类型都用固定大小的值来表示.
  当处理多字节数值时, 务必在编解码时使用相同的**字节序**
  (`byte-order` 或 `endianness`),
  **字节序**决定了一组字节的先后顺序.
  - **大端**: 从最高有效字节 (MSB) 开始,
    从高位到低位依次排列.
    换句话说, 最高有效字节具有最低的地址.
  - **小端**: 从最低有效字节 (LSB) 开始,
    从低位到高位依次排列.

* 通常, 在设计一种文件格式时, 首先要确定寻址方式:
  是否要将文件拆分为相同大小的页,
  哪些页由单个块或多个连续块所组成.
* 大多数原地更新的存储结构都使用相同大小的页,
  从而大大简化了读取和写入访问.
* 仅追加 (append-only) 的存储结构通常也按页写入数据:
  记录被一条一条地追加上去, 一旦内存中该页写满了,
  就将其刷写到磁盘上.
* 文件通常以定长的头部 (header) 开始, 可能以一个定长的尾部
  (trailer) 结束.
  - 尾部包含需要被快速访问的辅助信息或解析文件其余部分所必要的信息.

* 数据库将数据记录存储在数据文件和索引文件中.
  这些文件被划分为固定大小的单元, 称为页.
  - 页大小通常是文件系统块的整数倍, 一般是 `4~16KB`.

* 从数据结构的角度来看, 在`B`树中, 我们区分了叶节点
  (包含键和数据记录对) 与非叶节点 (包含键和指向其他节点的指针).
  - 每个`B`树节点占据一个页或多个链接在一起的页,
    因此在讨论B树时, "节点"和"页" (甚至"块")
    这几个术语经常可以互换使用.

* 空间回收可以通过简单地重写页并移动记录来完成,
  但是需要保证记录的偏移量不变, 因为页外的指针会用到这些偏移量.
  在做到这一点的同时, 我们希望尽可能减少空间浪费.
* 总之, 我们需要一种页格式, 它允许我们:
  - 以最小的开销存储变长记录
  - 回收已删除记录所占用的空间
  - 引用页中的记录, 无论这些记录具体在什么位置

* 我们将页组织成一个槽或单元格 (cell) 的集合,
  并将指针和单元格分别存放在页两侧的独立内存区域中.
  若想保持记录原来的顺序, 我们只需要重新组织指向单元格的指针;
  若要删除一条记录, 我们只需将记录的指针置为空或删除指针即可.
* 分槽页具有一个固定大小的头部, 其中包含关于页和单元格的重要信息.
  单元格的大小可能各不相同, 并且可以容纳任意数据:
  - 键, 指针, 数据记录等.

* **最小开销**: 分槽页唯一的额外开销是一个指针数组,
  用于保存记录实际所在位置的偏移量.
* **空间回收**: 通过对页进行碎片整理和重写, 就可以回收空间.
* **动态布局**: 从页外部, 只能通过槽`ID`来引用槽,
  而确切的位置是由页内部决定的.

* 我们假定单个页内所有单元格是统一的
  - 例如, 要么全是键单元格, 要么全是键值单元格;
  - 类似地, 要么全都包含定长数据, 要么全都包含变长数据,
    但不能是二者的混合.
* 这样一来, 单元格的元数据只要在每个页上保存一份即可,
  而不用让每个单元格都保存一份.

* 从页删除一条记录不用删除实际的单元格,
  也不用移动其他单元格以重用这些释放的空间.
  相反, 可以将这个单元格标记为已删除,
  并根据被释放内存的大小以及指针更新内存中的可用列表.
* 可用列表保存了可用段的偏移量及其大小. 每当插入新单元格时,
  我们首先检查可用性列表, 看看是否有能放得下的段.

* 至于具体要使用哪一个空闲块, 是通过以下策略计算的:
  - **首次适配优先**
  - 这种方法可能会造成较大的额外开销,
    因为当我们把数据填进第一个合适的段之后,
    剩余的空间可能不够放下其他的单元格,
    因而被浪费掉了.
  - **最佳适配优先**
  - 在最佳适配中, 我们尝试寻找一个段,
    使得插入之后段内剩余的空间最小.

* 如果找不到足够长的连续字节来存放新的单元格,
  但有足够多的碎片字节可用, 我们会读出所有存活的单元格再重新写入,
  即对页进行碎片整理, 以回收空间来留给新的写入.
* 如果在碎片整理之后依然没有足够的可用空间, 我们就要创建一个溢出页.

* 非加密哈希和 `CRC` 不应当用于验证数据是否已被篡改.
  对于这类场景, 请务必使用专为安全性设计的强加密哈希.
* `CRC` 的主要目标是确保数据没有非人为的, 意外的变化,
  而非用于抵御攻击或人为的修改.

* 由于计算整个文件的校验和通常是不切实际的,
  而且不太可能每次访问文件都读取全部内容,
  所以校验和通常是针对每个页计算的, 并保存在页头部.
* 这样一来, 校验和可以更健壮 (因为仅针对一小部分数据),
  而且就算单个页发生损坏, 我们也不用丢弃整个文件.

## B树的实现

* 存储同级指针的缺点之一是在分裂和合并期间必须更新它们.
  由于更新必须在同级节点中进行,
  而不是在`分裂/合并`节点中进行,
  所以可能需要额外的锁.

* `B`树分隔键有严格的不变式: 它用于将树拆分为子树并对这些子树进行遍历,
  因此指向子页的指针总是比指向键的指针多一个.
* 在许多实现中: 每个分隔键都有一个子指针, 而最后一个指针则单独存储,
  因为它并没有与任何键相匹配.
* 如果最右侧的子指针被拆分, 并且新的单元格被追加到其父节点上,
  则必须重新分配最右子指针.

* `B`树算法规定每个节点持有特定数量的元素. 由于某些值具有不同的大小,
  所以根据`B`树算法, 可能会出现这样一种情况:
  - 节点尚未满, 但保存该节点固定大小的页上已经没有更多的可用空间了.
  - 调整页大小需要将已经写入的数据复制到新区域, 这通常是不切实际的.
    但我们仍然需要找到一种方法来增加或扩展页大小.
* 为了实现变长节点而无须将数据复制到新的连续区域,
  我们可以从多个链接起来的页中构建节点.
  - 例如, 默认页大小为`4K`, 而在插入几个值之后, 其数据大小增长到`4K`以上.
  - 此时我们并不使用任意大小的页, 而是允许节点以`4K`为增量进行增长,
    因此我们可以分配一个`4K`的扩展页, 并从原始页链接到它.
  - 这些链接起来的页被称为溢出页 (overflow page),
    我们将原始页称为主页 (primary page).

* 二分搜索算法接收一个包含已排序元素的数组和一个搜索键, 并返回一个数字.
  如果返回的数字是整数, 则我们找到了要搜索的键,
  并且数字指定了它在输入数组中的位置.
  而返回值为负数则表示搜索到的键不存在于输入数组中, 并给出了一个插入点.

* 如果节点被分裂或合并, 则可以使用导航信息来为上拉到父节点的键查找插入点,
  并在必要时沿着树向上走, 以将结构更改传播到更高层的节点.
  - 这个栈一般在内存中维护.

* 一些`B`树的实现方案试图推迟分裂和合并操作, 以便通过在层内再平衡各元素来平摊代价,
  或将元素从占用较多的节点转移到占用较少的节点中, 通过这一方式尽可能推迟分裂或合并.
  - 虽然维护代价可能更高一些, 但这有助于提高节点利用率以及减少树的层数.

* 许多数据库系统使用单调自增的数值作为主索引的键. 这为优化创造了机会,
  因为所有的插入都发生在索引的末尾 (在最右边的叶子中),
  所以大多数分裂发生在每层的最右节点上.
* 此外, 由于键是单调递增的, 所以考虑到追加相对更新和删除的比例很低,
  相对于键随机排列的情况而言, 非叶页上的碎片化程度更低.

* 我们可以在不同的粒度级别上进行压缩. 尽管压缩整个文件可以产生更好的压缩率,
  但由于整个文件必须在更新时被重新压缩, 所以它的应用有限.
  - 更细粒度的压缩通常更适合较大的数据集.

## 事务处理与恢复

* 页缓存充当了持久性存储 (磁盘) 和存储引擎其余部分之间的中介.
  它将状态更改暂存在内存中, 同时也用于缓存那些尚未与持久性存储同步的页.
  一切数据库状态的更改都首先被应用在缓存的页上.
* 日志管理器记录了已应用在缓存页上的操作 (日志条目),
  这些操作尚未与持久性存储同步, 而日志可以确保这些操作不会在崩溃时丢失.
  - 换句话说, 在数据库启动期间, 我们利用日志来重新应用这些操作并重建缓存状态.
    日志条目也可以用来撤销已中止的事务所做的更改.

## B树的变体

## 日志结构存储

## 分布式系统简介

## 故障检测

## 领导者选举

## 复制和一致性

## 反熵和传播

## 分布式事务

## 共识
